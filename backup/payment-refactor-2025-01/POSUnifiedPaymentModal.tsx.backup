import { FC, useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { CashMethodFields, CardMethodFields, OfflineMethodFields } from '@app/components/payments/unified';
import ManualCardEntry, { ManualCardFormHandle, CardSubmissionResult } from '../../orders/payment/ManualCardEntryForms';
import usePaymentComposer, { PaymentEntry } from '@domains/payments/hooks/usePaymentComposer';
import usePaymentSettingsConfig from '@domains/payments/hooks/usePaymentSettingsConfig';
import {
  getPaymentMethods,
  getPaymentMethodsWithOptions,
  PaymentMethodConfig,
} from '@shared/utils/paymentMethods';
import { orderContainsGiftCards } from '@shared/utils/giftCardHelpers';
import GiftCardActivationModal from '../../orders/payment/GiftCardActivationModal';
import GiftCardHandoffModal from '../../orders/payment/GiftCardHandoffModal';
import NotificationModal from './NotificationModal';
import OrderCompletionSummary from './OrderCompletionSummary';
import stripeService from '@shared/legacy-services/stripeService';

type QuickActionsState = {
  emailReceipt: boolean;
  printReceipt: boolean;
};

type CompletionData = {
  transactionNumber: string;
  transactionId: string;
  totalAmount: number;
  paymentMethods: Array<{ method: string; amount: number; details?: any }>;
  completedOrders: Array<{
    id: string;
    type: 'delivery' | 'pos';
    customerName?: string;
    total: number;
  }>;
};

type Props = {
  open: boolean;
  total: number;
  cartItems?: any[];
  customer?: {
    id?: string;
    firstName?: string | null;
    lastName?: string | null;
    email?: string | null;
    phone?: string | null;
  } | null;
  customerName?: string;
  orderIds?: string[];
  employeeId?: string;
  taxAmount?: number;
  tipAmount?: number;
  onComplete: (transactionData?: any) => void;
  onCancel: () => void;
};

type UiPaymentMethod = {
  value: string;
  label: string;
  baseId: string;
  provider?: 'stripe' | 'square';
  config: PaymentMethodConfig;
};

type SavedCardOption = {
  id: string;
  label: string;
  provider: 'stripe' | 'square';
};

const EXCLUDED_METHODS = new Set(['split', 'other_methods']);

const formatCurrency = (value: number) => `$${value.toFixed(2)}`;

const transformCartToOrders = (cartItems: any[] = [], customerName?: string) => {
  if (!cartItems.length) return [];
  return [
    {
      id: 'pos-order',
      type: 'pos' as const,
      customerName,
      total: cartItems.reduce((sum, item) => sum + (item.unitPrice ?? 0) * (item.quantity ?? 0), 0),
    },
  ];
};

const mapPaymentMethodType = (method: string): string => {
  const methodMap: Record<string, string> = {
    cash: 'CASH',
    credit: 'CARD',
    debit: 'CARD',
    gift_card: 'GIFT_CARD',
    store_credit: 'STORE_CREDIT',
    check: 'CHECK',
    cod: 'COD',
    house_account: 'HOUSE_ACCOUNT',
  };

  if (method.startsWith('offline:') || method === 'wire') {
    return 'OFFLINE';
  }

  return methodMap[method] || 'CASH';
};

const getPaymentProvider = (method: string, providerFromMetadata?: string): string => {
  if (providerFromMetadata) return providerFromMetadata.toUpperCase();
  if (method === 'credit' || method === 'debit') return 'SQUARE';
  return 'INTERNAL';
};

const POSUnifiedPaymentModal: FC<Props> = ({
  open,
  total,
  cartItems = [],
  customer,
  customerName,
  orderIds = [],
  employeeId,
  taxAmount = 0,
  tipAmount = 0,
  onComplete,
  onCancel,
}) => {
  const { payments, addPayment, removePayment, resetPayments, remaining, hasBalance } = usePaymentComposer({ total });

  const { settings: paymentSettings, offlineMethods } = usePaymentSettingsConfig();
  const availableMethods: UiPaymentMethod[] = useMemo(() => {
    const base = paymentSettings
      ? getPaymentMethodsWithOptions('pos', {
          builtIn: paymentSettings.builtInMethods,
          offlineMethods,
        })
      : getPaymentMethods('pos');

    return base
      .filter((method) => !EXCLUDED_METHODS.has(method.id))
      .flatMap((method) => {
        if (method.id === 'credit') {
          return [
            {
              value: 'credit|square',
              label: 'Card (Square Reader)',
              baseId: 'credit',
              provider: 'square' as const,
              config: method,
            },
            {
              value: 'credit|stripe',
              label: 'Card (Stripe)',
              baseId: 'credit',
              provider: 'stripe' as const,
              config: method,
            },
          ];
        }

        return [
          {
            value: method.id,
            label: method.label,
            baseId: method.id,
            config: method,
          },
        ];
      });
  }, [paymentSettings, offlineMethods]);

  const [selectedMethod, setSelectedMethod] = useState<string>('credit|square');
  const [amountInput, setAmountInput] = useState<string>(total.toFixed(2));
  const [referenceValue, setReferenceValue] = useState<string>('');
  const [error, setError] = useState<string | null>(null);

  const [quickActions, setQuickActions] = useState<QuickActionsState>({
    emailReceipt: false,
    printReceipt: false,
  });

  const toggleQuickAction = (key: keyof QuickActionsState) => {
    setQuickActions((prev) => ({ ...prev, [key]: !prev[key] }));
  };

  const [cardMode, setCardMode] = useState<'terminal' | 'manual'>('terminal');
  const [cardProcessing, setCardProcessing] = useState(false);
  const [cardReady, setCardReady] = useState(true);
  const cardFormRef = useRef<ManualCardFormHandle | null>(null);
  const assignCardForm = useCallback((instance: ManualCardFormHandle | null) => {
    cardFormRef.current = instance;
  }, []);

  const [savedCards, setSavedCards] = useState<SavedCardOption[]>([]);
  const [savedCardCustomer, setSavedCardCustomer] = useState<any>(null);
  const [selectedSavedCard, setSelectedSavedCard] = useState<string | null>(null);

  const [autoCompletePending, setAutoCompletePending] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);

  const [showGiftCardActivation, setShowGiftCardActivation] = useState(false);
  const [giftCardNumbers, setGiftCardNumbers] = useState<any[]>([]);
  const [showGiftCardHandoff, setShowGiftCardHandoff] = useState(false);
  const [activatedGiftCards, setActivatedGiftCards] = useState<any[]>([]);

  const [showNotificationModal, setShowNotificationModal] = useState(false);
  const [notificationStatus, setNotificationStatus] = useState<{ type: 'success' | 'error'; message: string } | null>(null);

  const [completionData, setCompletionData] = useState<CompletionData | null>(null);
  const [showCompletion, setShowCompletion] = useState(false);

  const methodOption = availableMethods.find((method) => method.value === selectedMethod) ?? availableMethods[0];
  const methodConfig = methodOption?.config;
  const baseMethodId = methodOption?.baseId ?? '';
  const providerLabel = methodOption?.provider === 'stripe' ? 'Stripe' : 'Square';

  const customerDisplayName =
    customerName || [customer?.firstName, customer?.lastName].filter(Boolean).join(' ').trim();

  const hasGiftCards = useMemo(
    () => (cartItems && cartItems.length > 0 ? orderContainsGiftCards(cartItems) : false),
    [cartItems],
  );

  const enteredAmount = parseFloat(amountInput || '0');
  const coversRemaining = !Number.isNaN(enteredAmount) && Math.abs(enteredAmount - remaining) < 0.01;
  const manualEntryAmount = Number.isFinite(enteredAmount) ? Math.max(0, enteredAmount) : 0;
  const hasValidCardAmount = manualEntryAmount > 0;
  const hasValidCashAmount = !Number.isNaN(enteredAmount) && enteredAmount > 0;
  const isCardMethod = methodOption?.baseId === 'credit';
  const isOfflineMethod =
    baseMethodId === 'house_account' ||
    baseMethodId === 'check' ||
    baseMethodId === 'cod' ||
    baseMethodId.startsWith('offline:');

  const offlineMeta = methodConfig?.meta ?? {};
  const requiresReference =
    baseMethodId === 'check' ||
    (isOfflineMethod && typeof offlineMeta?.requiresReference === 'boolean' ? offlineMeta.requiresReference : false);
  const referenceMissing = requiresReference && referenceValue.trim().length === 0;

  const offlineReferenceLabel =
    baseMethodId === 'check'
      ? 'Check Number'
      : baseMethodId === 'house_account'
      ? 'Account Reference'
      : baseMethodId === 'cod'
      ? 'Delivery Notes'
      : 'Reference';

  const summaryPayments = payments.reduce((sum, payment) => sum + payment.amount, 0);

  const resetDraft = (nextRemainingValue?: number) => {
    const base = typeof nextRemainingValue === 'number' ? nextRemainingValue : remaining;
    const normalized = Number.isFinite(base) ? Math.max(0, Number(base.toFixed(2))) : Math.max(0, Number(remaining.toFixed(2)));
    setReferenceValue('');
    setAmountInput(normalized.toFixed(2));
  };

  const validateAmount = (): number | null => {
    const parsed = parseFloat(amountInput);
    if (Number.isNaN(parsed) || parsed <= 0) {
      setError('Enter a valid amount to apply.');
      return null;
    }
    if (parsed - remaining > 0.01) {
      setError('Amount exceeds remaining balance.');
      return null;
    }
    setError(null);
    return parsed;
  };

  const handleCardComplete = useCallback(
    (amount: number, submission?: CardSubmissionResult['result']) => {
      const metadata = submission
        ? {
            ...submission,
            provider: submission.provider ?? methodOption?.provider ?? 'square',
          }
        : {
            provider: methodOption?.provider ?? 'square',
          };

      addPayment({
        method: 'credit',
        amount,
        metadata,
      });

      const nextRemaining = Math.max(0, Number((remaining - amount).toFixed(2)));
      resetDraft(nextRemaining);
      setError(null);

      if (nextRemaining <= 0.01) {
        setAutoCompletePending(true);
      }
    },
    [addPayment, methodOption?.provider, remaining],
  );

  const submitCashPayment = useCallback(() => {
    if (remaining <= 0) {
      setError('Payment total already satisfied.');
      return;
    }

    const parsed = parseFloat(amountInput);
    if (Number.isNaN(parsed) || parsed <= 0) {
      setError('Enter the cash amount received.');
      return;
    }

    const amountToApply = Math.min(parsed, remaining);
    const changeDue = parsed > amountToApply ? Number((parsed - amountToApply).toFixed(2)) : 0;

    addPayment({
      method: 'cash',
      amount: Number(amountToApply.toFixed(2)),
      metadata: {
        cashReceived: Number(parsed.toFixed(2)),
        changeDue,
      },
    });

    const nextRemaining = Math.max(0, Number((remaining - amountToApply).toFixed(2)));
    resetDraft(nextRemaining);
    setError(null);

    if (nextRemaining <= 0.01) {
      setAutoCompletePending(true);
    }
  }, [addPayment, amountInput, remaining]);

  const startReaderPayment = useCallback(async () => {
    if (cardProcessing) return;
    const amount = validateAmount();
    if (amount === null) return;

    setCardProcessing(true);
    setError(null);

    try {
      await new Promise((resolve) => setTimeout(resolve, 2000));

      handleCardComplete(amount, {
        success: true,
        result: {
          method: 'credit',
          provider: methodOption?.provider ?? 'square',
          transactionId: `${methodOption?.provider ?? 'square'}_${Date.now()}`,
        },
      });
    } catch (readerError) {
      console.error('Card reader failed:', readerError);
      setError(readerError instanceof Error ? readerError.message : 'Card reader failed. Try again.');
    } finally {
      setCardProcessing(false);
    }
  }, [cardProcessing, handleCardComplete, methodOption?.provider, validateAmount]);

  const loadSavedCards = useCallback(async () => {
    if (!customer?.email && !customer?.phone) {
      setSavedCards([]);
      setSavedCardCustomer(null);
      setSelectedSavedCard(null);
      return;
    }

    try {
      if (methodOption?.provider === 'stripe') {
        const result = await stripeService.getCustomerPaymentMethods(customer?.phone ?? undefined, customer?.email ?? undefined);
        if (result.success && result.paymentMethods.length > 0) {
          const options: SavedCardOption[] = [
            { id: 'manual', label: 'Use new card', provider: 'stripe' },
            ...result.paymentMethods.map((card: any) => ({
              id: card.id,
              label: `${card.cardBrand?.toUpperCase?.() || 'Card'} •••• ${card.last4} (${String(card.expMonth).padStart(2, '0')}/${card.expYear})`,
              provider: 'stripe' as const,
            })),
          ];
          setSavedCards(options);
          setSavedCardCustomer(result.customer);
          setSelectedSavedCard('manual');
        } else {
          setSavedCards([]);
          setSavedCardCustomer(null);
          setSelectedSavedCard(null);
        }
      } else if (methodOption?.provider === 'square') {
        const result = await stripeService.getSquareCustomerPaymentMethods(customer?.phone ?? undefined, customer?.email ?? undefined);
        if (result.success && result.paymentMethods.length > 0) {
          const options: SavedCardOption[] = [
            { id: 'manual', label: 'Use new card', provider: 'square' },
            ...result.paymentMethods.map((card: any) => ({
              id: card.id,
              label: `${card.cardBrand?.toUpperCase?.() || 'Card'} •••• ${card.last4}`,
              provider: 'square' as const,
            })),
          ];
          setSavedCards(options);
          setSavedCardCustomer(result.customer);
          setSelectedSavedCard('manual');
        } else {
          setSavedCards([]);
          setSavedCardCustomer(null);
          setSelectedSavedCard(null);
        }
      } else {
        setSavedCards([]);
        setSavedCardCustomer(null);
        setSelectedSavedCard(null);
      }
    } catch (loadError) {
      console.error('Failed to load saved cards:', loadError);
      setSavedCards([]);
      setSavedCardCustomer(null);
      setSelectedSavedCard(null);
    }
  }, [customer?.email, customer?.phone, methodOption?.provider]);

  const handleSavedCardPayment = useCallback(
    async (amount: number) => {
      if (!selectedSavedCard || selectedSavedCard === 'manual' || !savedCardCustomer) {
        setSelectedSavedCard(null);
        return;
      }

      setCardProcessing(true);
      setError(null);

      try {
        if (methodOption?.provider === 'stripe') {
          let clientSecret: string | null = null;
          const intent = await stripeService.createPaymentIntent({
            amount,
            currency: 'cad',
            customerEmail: customer?.email ?? undefined,
            customerPhone: customer?.phone ?? undefined,
            customerName: customerDisplayName || undefined,
            orderIds,
            description: `POS Order ${orderIds?.join(', ') || ''}`,
          });
          clientSecret = intent.clientSecret;

          const stripe = await stripeService.getStripe();
          if (!stripe || !clientSecret) {
            throw new Error('Stripe not initialised');
          }

          const { error: stripeError, paymentIntent } = await stripe.confirmPayment({
            clientSecret,
            confirmParams: {
              payment_method: selectedSavedCard,
              return_url: `${window.location.origin}/pos`,
            },
            redirect: 'if_required',
          });

          if (stripeError) {
            throw new Error(stripeError.message || 'Payment failed');
          }

          if (paymentIntent && paymentIntent.status === 'succeeded') {
            handleCardComplete(amount, {
              success: true,
              result: {
                method: 'credit',
                provider: 'stripe',
                transactionId: paymentIntent.id,
                paymentIntentId: paymentIntent.id,
              },
            });
          } else {
            throw new Error('Payment not completed');
          }
        } else if (methodOption?.provider === 'square') {
          const result = await stripeService.processSquareSavedCardPayment({
            amount,
            customerId: savedCardCustomer.id,
            customerCardId: selectedSavedCard,
            description: `POS Order ${orderIds?.join(', ') || ''}`,
            orderIds,
          });

          if (!result.success) {
            throw new Error('Square payment failed');
          }

          handleCardComplete(amount, {
            success: true,
            result: {
              method: 'credit',
              provider: 'square',
              transactionId: result.paymentId,
            },
          });
        }
      } catch (savedError) {
        console.error('Saved card payment failed:', savedError);
        setError(savedError instanceof Error ? savedError.message : 'Saved card payment failed.');
      } finally {
        setCardProcessing(false);
      }
    },
    [
      customer?.email,
      customer?.phone,
      customerDisplayName,
      handleCardComplete,
      methodOption?.provider,
      orderIds,
      savedCardCustomer,
      selectedSavedCard,
    ],
  );

  const submitCardPayment = useCallback(async () => {
    if (!methodConfig) {
      setError('Select a payment method.');
      return;
    }

    if (cardProcessing) return;

    const amount = validateAmount();
    if (amount === null) return;

    if (cardMode === 'terminal') {
      await startReaderPayment();
      return;
    }

    if (selectedSavedCard && selectedSavedCard !== 'manual') {
      await handleSavedCardPayment(amount);
      return;
    }

    const form = cardFormRef.current;
    if (!form) {
      setError('Card entry is unavailable. Try reselecting the payment method.');
      return;
    }

    if (!cardReady) {
      setError('Card entry is still initializing. Please wait a moment.');
      return;
    }

    const result = await form.submit();
    if (result.success && result.result) {
      handleCardComplete(amount, result.result);
    }
  }, [
    cardMode,
    cardProcessing,
    cardReady,
    handleCardComplete,
    handleSavedCardPayment,
    methodConfig,
    selectedSavedCard,
    startReaderPayment,
    validateAmount,
  ]);

  const handleAddOfflinePayment = useCallback(() => {
    if (!methodConfig) {
      setError('Select a payment method.');
      return;
    }

    if (requiresReference && referenceMissing) {
      setError(`${offlineReferenceLabel} is required.`);
      return;
    }

    const amount = validateAmount();
    if (amount === null) return;

    const metadata: Record<string, any> = {};
    if (referenceValue.trim()) {
      metadata.reference = referenceValue.trim();
      if (baseMethodId === 'check') {
        metadata.checkNumber = referenceValue.trim();
      }
    }
    if (baseMethodId.startsWith('offline:')) {
      metadata.offlineMethodId = methodConfig.id?.split(':')[1];
    }

    addPayment({
      method: baseMethodId,
      amount,
      metadata,
    });

    const nextRemaining = Math.max(0, Number((remaining - amount).toFixed(2)));
    resetDraft(nextRemaining);
    setError(null);

    if (nextRemaining <= 0.01) {
      setAutoCompletePending(true);
    }
  }, [addPayment, baseMethodId, methodConfig, referenceMissing, referenceValue, requiresReference, remaining, validateAmount]);

  const handleNotificationSuccess = (message: string) => {
    setShowNotificationModal(false);
    setNotificationStatus({ type: 'success', message });
    setTimeout(() => setNotificationStatus(null), 3000);
  };

  const handleNotificationError = (message: string) => {
    setNotificationStatus({ type: 'error', message });
    setTimeout(() => setNotificationStatus(null), 4000);
  };

  const handleNewOrder = () => {
    setShowCompletion(false);
    setCompletionData(null);
    resetPayments();
    setQuickActions({ emailReceipt: false, printReceipt: false });
    onComplete();
  };

  const handleProcessPayment = useCallback(async () => {
    if (remaining > 0.01) {
      setError('Payments do not cover the total amount.');
      return;
    }

    if (hasGiftCards && giftCardNumbers.length === 0) {
      setShowGiftCardActivation(true);
      return;
    }

    setIsProcessing(true);
    setError(null);

    try {
      let customerId = customer?.id;
      if (!customerId) {
        const guestResponse = await fetch('/api/customers', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            firstName: 'Walk-in',
            lastName: 'Customer',
            email: null,
            phone: null,
          }),
        });

        if (!guestResponse.ok) {
          throw new Error('Failed to create guest customer');
        }

        const guestCustomer = await guestResponse.json();
        customerId = guestCustomer.id;
      }

      const paymentMethodsForApi = payments.map((payment) => {
        const base = {
          type: mapPaymentMethodType(payment.method),
          provider: getPaymentProvider(payment.method, payment.metadata?.provider),
          amount: payment.amount,
        };

        if (payment.method === 'credit') {
          return {
            ...base,
            providerTransactionId: payment.metadata?.transactionId,
            paymentIntentId: payment.metadata?.paymentIntentId,
            cardLast4: payment.metadata?.cardLast4,
            cardBrand: payment.metadata?.cardBrand,
          };
        }

        if (payment.method === 'check') {
          return {
            ...base,
            checkNumber: payment.metadata?.checkNumber || payment.metadata?.reference,
            providerMetadata: payment.metadata?.reference ? { reference: payment.metadata.reference } : undefined,
          };
        }

        if (payment.method === 'house_account' || payment.method === 'cod') {
          return {
            ...base,
            providerMetadata: payment.metadata?.reference ? { reference: payment.metadata.reference } : undefined,
          };
        }

        if (payment.method.startsWith('offline:')) {
          return {
            ...base,
            offlineMethodId: payment.metadata?.offlineMethodId,
            providerMetadata: payment.metadata?.reference ? { reference: payment.metadata.reference } : undefined,
          };
        }

        return base;
      });

      const transactionResponse = await fetch('/api/payment-transactions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          customerId,
          employeeId,
          channel: 'POS',
          totalAmount: payments.reduce((sum, payment) => sum + payment.amount, 0),
          taxAmount,
          tipAmount,
          notes: `POS transaction for ${customerDisplayName || 'Walk-in Customer'}`,
          paymentMethods: paymentMethodsForApi,
          orderIds,
        }),
      });

      if (!transactionResponse.ok) {
        const errorData = await transactionResponse.json();
        throw new Error(errorData.error || 'Failed to process payment');
      }

      const transaction = await transactionResponse.json();

      if (giftCardNumbers.length > 0) {
        const { purchaseGiftCards } = await import('@shared/legacy-services/giftCardService');
        const cards = giftCardNumbers.map((card) => ({
          cardNumber: card.cardNumber,
          amount: card.amount,
          type: card.type || 'PHYSICAL',
          recipientName: card.recipientName || customerDisplayName,
          recipientEmail: card.recipientEmail,
        }));

        try {
          const purchaseResult = await purchaseGiftCards(cards, customerId, employeeId, transaction.id);
          setActivatedGiftCards(purchaseResult.cards);
          setShowGiftCardHandoff(true);
        } catch (giftError: any) {
          setError(`Payment completed, but gift card activation failed: ${giftError.message}`);
        }
      }

      const completion: CompletionData = {
        transactionNumber: transaction.transactionNumber,
        transactionId: transaction.id,
        totalAmount: payments.reduce((sum, payment) => sum + payment.amount, 0),
        paymentMethods: payments.map((payment) => ({
          method: payment.method,
          amount: payment.amount,
          details: payment.metadata,
        })),
        completedOrders: transformCartToOrders(cartItems, customerDisplayName),
      };

      setCompletionData(completion);
      setShowCompletion(true);
      resetPayments();
      setAutoCompletePending(false);

      if (quickActions.emailReceipt) {
        setShowNotificationModal(true);
      }
      if (quickActions.printReceipt) {
        console.log('🖨️ Printing receipt for', transaction.transactionNumber);
      }

      onComplete({
        transactionNumber: transaction.transactionNumber,
        transactionId: transaction.id,
        totalAmount: completion.totalAmount,
        customerId,
        orderIds,
      });
    } catch (processingError) {
      console.error('Payment processing failed:', processingError);
      setError(processingError instanceof Error ? processingError.message : 'Payment processing failed');
    } finally {
      setIsProcessing(false);
      setCardProcessing(false);
    }
  }, [
    cartItems,
    customer?.id,
    customer?.email,
    customer?.phone,
    customerDisplayName,
    employeeId,
    giftCardNumbers,
    hasGiftCards,
    onComplete,
    orderIds,
    payments,
    quickActions.emailReceipt,
    quickActions.printReceipt,
    remaining,
    resetPayments,
    taxAmount,
    tipAmount,
  ]);

  useEffect(() => {
    if (!autoCompletePending) return;
    if (isProcessing || cardProcessing) return;
    if (remaining > 0.01) return;
    void handleProcessPayment();
  }, [autoCompletePending, cardProcessing, handleProcessPayment, isProcessing, remaining]);

  useEffect(() => {
    if (!open) {
      setSelectedMethod('credit|square');
      setAmountInput(total.toFixed(2));
      setReferenceValue('');
      setQuickActions({ emailReceipt: false, printReceipt: false });
      setCardMode('terminal');
      setCardProcessing(false);
      setCardReady(true);
      setAutoCompletePending(false);
      setError(null);
      setSavedCards([]);
      setSavedCardCustomer(null);
      setSelectedSavedCard(null);
      resetPayments();
      return;
    }
    resetDraft();
  }, [open, total, resetPayments]);

  useEffect(() => {
    if (!open) return;
    if (!methodOption) {
      setSelectedMethod(availableMethods[0]?.value ?? '');
    }
  }, [open, methodOption, availableMethods]);

  useEffect(() => {
    if (!open) return;
    if (cardMode !== 'manual') {
      setSavedCards([]);
      setSavedCardCustomer(null);
      setSelectedSavedCard(null);
      setCardReady(true);
      return;
    }
    setCardReady(false);
    void loadSavedCards();
  }, [cardMode, loadSavedCards, open]);

  const paymentItems = payments.map((payment, index) => ({
    id: `${payment.method}-${index}`,
    label: (() => {
      if (payment.method === 'credit') {
        const provider = payment.metadata?.provider === 'stripe' ? 'Stripe' : 'Square';
        return `Card (${provider})`;
      }
      if (payment.method === 'cash') return 'Cash';
      const offlineMatch = availableMethods.find(
        (method) => method.baseId === payment.method && method.config.offlineId === payment.metadata?.offlineMethodId,
      );
      if (offlineMatch) return offlineMatch.label;
      const match =
        availableMethods.find((method) => method.config.id === payment.method) ||
        availableMethods.find((method) => method.baseId === payment.method);
      return match?.label ?? payment.method;
    })(),
    amount: payment.amount,
    meta:
      payment.metadata?.reference ||
      (payment.method === 'cash' && payment.metadata?.cashReceived
        ? `Received ${formatCurrency(payment.metadata.cashReceived)}${
            payment.metadata?.changeDue ? ` • Change ${formatCurrency(payment.metadata.changeDue)}` : ''
          }`
        : undefined),
    onRemove: () => removePayment(index),
  }));

  const canFinalize = !hasBalance && payments.length > 0;
  const manualReady = cardMode === 'manual' ? cardReady || (selectedSavedCard !== null && selectedSavedCard !== 'manual') : true;

  const primaryActionLabel = (() => {
    if (canFinalize) return 'Complete Payment';
    if (isCardMethod) {
      if (cardMode === 'manual') {
        if (selectedSavedCard && selectedSavedCard !== 'manual') {
          return `Charge Saved Card (${providerLabel})`;
        }
        return `Process Card (${providerLabel})`;
      }
      return `Start Reader (${providerLabel})`;
    }
    if (baseMethodId === 'cash') {
      return coversRemaining ? 'Complete Payment' : 'Add Cash Payment';
    }
    if (isOfflineMethod) {
      return coversRemaining ? 'Complete Payment' : `Add ${methodOption?.label ?? 'Payment'}`;
    }
    return 'Add Payment';
  })();

  const primaryAction = () => {
    if (canFinalize) {
      void handleProcessPayment();
      return;
    }
    if (isCardMethod) {
      void submitCardPayment();
      return;
    }
    if (baseMethodId === 'cash') {
      submitCashPayment();
      return;
    }
    handleAddOfflinePayment();
  };

  const primaryDisabled = canFinalize
    ? isProcessing
    : isCardMethod
    ? cardProcessing ||
      isProcessing ||
      (cardMode === 'manual' ? (!hasValidCardAmount && (!selectedSavedCard || selectedSavedCard === 'manual') ? true : !manualReady) : false)
    : baseMethodId === 'cash'
    ? !hasValidCashAmount || isProcessing
    : isOfflineMethod
    ? !hasValidCashAmount || referenceMissing || isProcessing
    : remaining > 0.01 || isProcessing;

  if (!open) return null;

  if (showCompletion && completionData) {
    return (
      <>
        <div className="flex h-full w-full flex-col rounded-2xl border border-stroke bg-white shadow-2xl dark:border-strokedark dark:bg-boxdark">
          <div className="border-b border-stroke px-6 py-4 dark:border-strokedark">
            <h2 className="text-xl font-semibold text-black dark:text-white">Payment Complete</h2>
            <p className="text-sm text-gray-500 dark:text-gray-400">
              Transaction {completionData.transactionNumber} recorded.
            </p>
          </div>
          <div className="flex-1 overflow-y-auto p-6">
            <OrderCompletionSummary
              transactionId={completionData.transactionId}
              transactionNumber={completionData.transactionNumber}
              totalAmount={completionData.totalAmount}
              paymentMethods={completionData.paymentMethods}
              completedOrders={completionData.completedOrders}
              giftCards={activatedGiftCards}
              onSendReceipt={() => setShowNotificationModal(true)}
              onPrintReceipt={() => console.log('🖨️ Print receipt for', completionData.transactionNumber)}
              onProcessRefund={() => console.log('↩️ Process refund for', completionData.transactionNumber)}
              onNewOrder={handleNewOrder}
            />
          </div>
        </div>

        <NotificationModal
          isOpen={showNotificationModal}
          onClose={() => setShowNotificationModal(false)}
          transactionNumber={completionData.transactionNumber}
          transactionId={completionData.transactionId}
          total={completionData.totalAmount}
          customerEmail={customer?.email ?? undefined}
          customerPhone={customer?.phone ?? undefined}
          customerName={customerDisplayName}
          onSuccess={handleNotificationSuccess}
          onError={handleNotificationError}
          defaultChannels={['email']}
          title="Send Receipt"
        />

        <GiftCardHandoffModal
          open={showGiftCardHandoff}
          onClose={() => setShowGiftCardHandoff(false)}
          cards={activatedGiftCards}
          customerName={customerDisplayName}
          isDigital={activatedGiftCards.some((card) => card.type === 'DIGITAL')}
        />

        {notificationStatus && (
          <div
            className={`fixed top-4 right-4 z-[100001] px-6 py-4 rounded-lg shadow-lg text-white font-medium ${
              notificationStatus.type === 'success' ? 'bg-green-600' : 'bg-red-600'
            }`}
          >
            {notificationStatus.message}
          </div>
        )}
      </>
    );
  }

  return (
    <>
      <div className="flex h-full w-full flex-col rounded-2xl border border-stroke bg-white shadow-2xl dark:border-strokedark dark:bg-boxdark">
        <div className="flex items-center justify-between border-b border-stroke px-6 py-4 dark:border-strokedark">
          <div>
            <h2 className="text-xl font-semibold text-black dark:text-white">Collect Payment</h2>
            {customerDisplayName && (
              <p className="text-sm text-gray-500 dark:text-gray-400">Customer: {customerDisplayName}</p>
            )}
          </div>
          <button
            onClick={onCancel}
            className="text-gray-400 transition-colors hover:text-gray-600 dark:hover:text-gray-300"
            aria-label="Close payment panel"
          >
            <svg className="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        <div className="flex flex-1 flex-col lg:flex-row">
          <aside className="w-full border-b border-stroke p-6 dark:border-strokedark lg:w-64 lg:border-b-0 lg:border-r">
            <div className="space-y-4">
              <div className="rounded-xl border border-gray-200 p-4 dark:border-gray-700">
                <div className="flex justify-between text-sm">
                  <span className="text-gray-600 dark:text-gray-400">Order Total</span>
                  <span className="font-semibold text-gray-900 dark:text-white">{formatCurrency(total)}</span>
                </div>
                <div className="flex justify-between text-sm">
                  <span className="text-gray-600 dark:text-gray-400">Payments Added</span>
                  <span className="font-semibold text-gray-900 dark:text-white">{formatCurrency(summaryPayments)}</span>
                </div>
                <div className="flex justify-between text-sm">
                  <span className="text-gray-600 dark:text-gray-400">Remaining Balance</span>
                  <span className="font-semibold text-[#597485]">{formatCurrency(Math.max(0, remaining))}</span>
                </div>
                {(isProcessing || cardProcessing) && (
                  <div className="text-sm text-[#597485]">Processing payment…</div>
                )}
                {error && (
                  <div className="text-sm text-red-600 dark:text-red-400">{error}</div>
                )}
              </div>

              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <h3 className="text-sm font-semibold text-gray-700 dark:text-gray-300">Payments Added</h3>
                  <span className="text-xs text-gray-500 dark:text-gray-400">{payments.length}</span>
                </div>
                {payments.length === 0 ? (
                  <div className="rounded-xl border border-dashed border-gray-300 p-4 text-center text-sm text-gray-500 dark:border-gray-700 dark:text-gray-400">
                    No payments yet. Select a method to add one.
                  </div>
                ) : (
                  <div className="space-y-3">
                    {paymentItems.map((item) => (
                      <div
                        key={item.id}
                        className="flex items-center justify-between rounded-xl border border-gray-200 p-3 dark:border-gray-700"
                      >
                        <div>
                          <div className="text-sm font-semibold text-gray-900 dark:text-white">{item.label}</div>
                          {item.meta && (
                            <div className="text-xs text-gray-500 dark:text-gray-400">{item.meta}</div>
                          )}
                        </div>
                        <div className="flex items-center gap-3">
                          <span className="text-sm font-semibold text-[#597485]">{formatCurrency(item.amount)}</span>
                          <button
                            onClick={item.onRemove}
                            className="text-xs text-red-500 hover:text-red-600"
                            aria-label={`Remove ${item.label}`}
                          >
                            Remove
                          </button>
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </div>
          </aside>

          <main className="flex-1 overflow-y-auto p-6">
            <div className="space-y-6">
              <div className="rounded-xl border border-gray-200 p-4 dark:border-gray-700">
                <div className="grid gap-4 sm:grid-cols-2">
                  <div>
                    <label className="mb-2 block text-xs font-semibold text-gray-600 dark:text-gray-400">
                      Payment Method
                    </label>
                    <select
                      value={methodOption?.value ?? ''}
                      onChange={(event) => {
                        setSelectedMethod(event.target.value);
                        resetDraft();
                        setError(null);
                        setCardProcessing(false);
                        setAutoCompletePending(false);
                        setSavedCards([]);
                        setSavedCardCustomer(null);
                        setSelectedSavedCard(null);
                        cardFormRef.current = null;
                        if (event.target.value.startsWith('credit')) {
                          setCardMode('terminal');
                          setCardReady(true);
                        } else {
                          setCardMode('terminal');
                          setCardReady(true);
                        }
                      }}
                      className="w-full rounded border border-stroke bg-transparent py-3 px-4 text-sm font-medium outline-none transition focus:border-[#597485] focus:ring-2 focus:ring-[#597485]/20 dark:border-strokedark dark:bg-[#0f172a] dark:text-white"
                    >
                      {availableMethods.map((method) => (
                        <option key={method.value} value={method.value}>
                          {method.label}
                        </option>
                      ))}
                    </select>
                  </div>
                  <div>
                    <label className="mb-2 block text-xs font-semibold text-gray-600 dark:text-gray-400">
                      Payment Amount
                    </label>
                    <div className="flex items-center gap-3">
                      <input
                        type="number"
                        min="0"
                        step={0.01}
                        value={amountInput}
                        onChange={(event) => setAmountInput(event.target.value)}
                        className="w-full rounded border border-stroke bg-transparent py-3 px-4 text-sm outline-none transition focus:border-[#597485] focus:ring-2 focus:ring-[#597485]/20 dark:border-strokedark dark:bg-[#0f172a] dark:text-white"
                      />
                      <button
                        onClick={() => setAmountInput(Math.max(0, remaining).toFixed(2))}
                        className="text-xs font-medium text-[#597485] hover:text-[#4e6575]"
                      >
                        Autofill
                      </button>
                    </div>
                  </div>
                </div>
              </div>

              <div className="rounded-xl border border-gray-200 p-4 dark:border-gray-700">
                {baseMethodId === 'cash' ? (
                  <CashMethodFields
                    amountDue={remaining}
                    amountInput={amountInput}
                    onAmountChange={setAmountInput}
                    onProcessCash={submitCashPayment}
                    disabled={!hasValidCashAmount || isProcessing}
                    showProcessButton={false}
                  />
                ) : methodOption?.baseId === 'credit' ? (
                  <CardMethodFields
                    provider={methodOption.provider ?? 'square'}
                    mode={cardMode}
                    onModeChange={(mode) => {
                      setCardMode(mode);
                      if (mode === 'manual') {
                        setCardReady(false);
                        setCardProcessing(false);
                        void loadSavedCards();
                      } else {
                        setCardReady(true);
                        setCardProcessing(false);
                        setSavedCards([]);
                        setSavedCardCustomer(null);
                        setSelectedSavedCard(null);
                      }
                      cardFormRef.current = null;
                    }}
                    savedCards={savedCards.map((card) => ({ id: card.id, label: card.label }))}
                    selectedSavedCard={selectedSavedCard ?? ''}
                    onSelectSavedCard={(value) => setSelectedSavedCard(value || null)}
                    onProcessCard={() => {
                      if (cardMode === 'terminal') {
                        void startReaderPayment();
                      } else {
                        void submitCardPayment();
                      }
                    }}
                    disabled={cardProcessing || isProcessing}
                    note={
                      cardMode === 'terminal'
                        ? 'Reader mode for in-person tap/insert/swipe. Switch to manual for keyed entry or saved cards.'
                        : 'Keyed entry for fallback card payments. Saved cards appear when customer contact info is available.'
                    }
                    showProcessButton={false}
                  >
                    {cardMode === 'manual' ? (
                      <ManualCardEntry
                        ref={assignCardForm}
                        provider={methodOption.provider ?? 'square'}
                        amount={manualEntryAmount}
                        customerEmail={customer?.email ?? null}
                        customerPhone={customer?.phone ?? null}
                        customerName={customerDisplayName || null}
                        onProcessingChange={setCardProcessing}
                        onError={setError}
                        onReadyChange={setCardReady}
                      />
                    ) : (
                      <div className="space-y-4 text-sm text-gray-600 dark:text-gray-400">
                        <div className="rounded-lg border border-dashed border-gray-300 p-4 text-center dark:border-gray-700">
                          <div className="mb-1 text-lg font-semibold text-black dark:text-white">
                            {providerLabel} Card Reader
                          </div>
                          <p>Tap the button to start the reader and follow the prompts on the device.</p>
                        </div>
                        <button
                          onClick={() => void startReaderPayment()}
                          disabled={cardProcessing || isProcessing}
                          className="w-full rounded-xl bg-[#597485] py-3 text-sm font-semibold text-white transition hover:bg-[#4e6575] disabled:cursor-not-allowed disabled:opacity-50"
                        >
                          {cardProcessing ? 'Waiting for reader…' : `Start ${providerLabel} Reader`}
                        </button>
                      </div>
                    )}
                  </CardMethodFields>
                ) : (
                  <OfflineMethodFields
                    referenceLabel={offlineReferenceLabel}
                    referenceValue={referenceValue}
                    onReferenceChange={setReferenceValue}
                    instructions={offlineMeta.instructions ?? methodConfig?.description}
                    requireReference={requiresReference}
                    onProcess={handleAddOfflinePayment}
                    disabled={!hasValidCashAmount || referenceMissing || isProcessing}
                    showProcessButton={false}
                    processLabel={`Add ${methodOption?.label ?? 'Payment'}`}
                  />
                )}
              </div>
            </div>
          </main>
        </div>

        <div className="flex flex-col gap-4 border-t border-stroke px-6 py-4 dark:border-strokedark lg:flex-row lg:items-center lg:justify-between">
          <div className="flex flex-wrap items-center gap-3">
            <span className="text-xs font-semibold uppercase tracking-wide text-gray-500 dark:text-gray-400">
              Quick Actions
            </span>
            <button
              onClick={() => toggleQuickAction('emailReceipt')}
              className={`flex h-16 min-w-[140px] items-center justify-center rounded-xl border-2 px-4 text-sm font-semibold transition-colors ${
                quickActions.emailReceipt
                  ? 'border-[#597485] bg-[#597485] text-white shadow-lg'
                  : 'border-gray-200 bg-gray-100 text-gray-600 hover:border-[#597485] hover:text-[#597485]'
              }`}
            >
              Email Receipt
            </button>
            <button
              onClick={() => toggleQuickAction('printReceipt')}
              className={`flex h-16 min-w-[140px] items-center justify-center rounded-xl border-2 px-4 text-sm font-semibold transition-colors ${
                quickActions.printReceipt
                  ? 'border-[#597485] bg-[#597485] text-white shadow-lg'
                  : 'border-gray-200 bg-gray-100 text-gray-600 hover:border-[#597485] hover:text-[#597485]'
              }`}
            >
              Print Receipt
            </button>
          </div>
          <div className="flex items-center justify-end gap-3">
            <button
              onClick={onCancel}
              className="rounded-lg border border-stroke px-4 py-2 text-sm font-medium text-gray-600 transition hover:bg-gray-100 dark:border-strokedark dark:text-gray-300 dark:hover:bg-gray-800"
            >
              Cancel
            </button>
            <button
              onClick={() => {
                primaryAction();
              }}
              disabled={primaryDisabled}
              className="rounded-lg bg-[#597485] px-5 py-2.5 text-sm font-semibold text-white transition hover:bg-[#4e6575] disabled:cursor-not-allowed disabled:opacity-50"
            >
              {primaryActionLabel}
            </button>
          </div>
        </div>
      </div>

      <GiftCardActivationModal
        open={showGiftCardActivation}
        onClose={() => setShowGiftCardActivation(false)}
        orderItems={cartItems}
        onActivationComplete={(cardData) => {
          setGiftCardNumbers(cardData);
          setShowGiftCardActivation(false);
        }}
      />

      <NotificationModal
        isOpen={showNotificationModal && !!completionData}
        onClose={() => setShowNotificationModal(false)}
        transactionNumber={completionData?.transactionNumber}
        transactionId={completionData?.transactionId}
        total={completionData?.totalAmount ?? total}
        customerEmail={customer?.email ?? undefined}
        customerPhone={customer?.phone ?? undefined}
        customerName={customerDisplayName}
        onSuccess={handleNotificationSuccess}
        onError={handleNotificationError}
        defaultChannels={['email']}
        title="Send Receipt"
      />

      {notificationStatus && (
        <div
          className={`fixed top-4 right-4 z-[100001] px-6 py-4 rounded-lg shadow-lg text-white font-medium ${
            notificationStatus.type === 'success' ? 'bg-green-600' : 'bg-red-600'
          }`}
        >
          {notificationStatus.message}
        </div>
      )}
    </>
  );
};

export default POSUnifiedPaymentModal;
